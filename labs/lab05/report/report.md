---
## Front matter
title: "Отчет по лабораторной работе №5"
subtitle: "Дисциплина: Информационная безопасность"
author: "Выполнила: Афтаева Ксения Васильевна"

## Generic otions
lang: ru-RU
toc-title: "Содержание"

## Bibliography
bibliography: bib/cite.bib
csl: pandoc/csl/gost-r-7-0-5-2008-numeric.csl

## Pdf output format
toc: true # Table of contents
toc-depth: 2
lof: true # List of figures
lot: true # List of tables
fontsize: 12pt
linestretch: 1.5
papersize: a4
documentclass: scrreprt
## I18n polyglossia
polyglossia-lang:
  name: russian
  options:
	- spelling=modern
	- babelshorthands=true
polyglossia-otherlangs:
  name: english
## I18n babel
babel-lang: russian
babel-otherlangs: english
## Fonts
mainfont: PT Serif
romanfont: PT Serif
sansfont: PT Sans
monofont: PT Mono
mainfontoptions: Ligatures=TeX
romanfontoptions: Ligatures=TeX
sansfontoptions: Ligatures=TeX,Scale=MatchLowercase
monofontoptions: Scale=MatchLowercase,Scale=0.9
## Biblatex
biblatex: true
biblio-style: "gost-numeric"
biblatexoptions:
  - parentracker=true
  - backend=biber
  - hyperref=auto
  - language=auto
  - autolang=other*
  - citestyle=gost-numeric
## Pandoc-crossref LaTeX customization
figureTitle: "Рис."
tableTitle: "Таблица"
listingTitle: "Листинг"
lofTitle: "Список иллюстраций"
lotTitle: "Список таблиц"
lolTitle: "Листинги"
## Misc options
indent: true
header-includes:
  - \usepackage{indentfirst}
  - \usepackage{float} # keep figures where there are in the text
  - \floatplacement{figure}{H} # keep figures where there are in the text
---

# Цель работы

Изучение механизмов изменения, применения SetUID- и Sticky-битов. Получение практических навыков работы в консоли с дополнительными атрибутами. Рассмотрение работы механизма смены идентификатора процессов пользователей, а также влияние бита Sticky на запись и удаление файлов.

# Задачи

1. Подготовить лабораторный стенд, если это требуется.
2. Выполнить задания по созданию и компилированию программ.
3. Выполнить задания по исследованию Sticky-бита.

# Теоретическое введение

Изначально каждый файл имеет три параметра доступа [@key-1]:

 - **чтение** - разрешает прочитать содержимое файла или каталога (r);

 - **запись** - разрешает записывать новые данные в файл или изменять существующие, а также позволяет создавать и изменять файлы и каталоги (w);

 - **выполнение** - разрешает выполнять, как программу, и входить в директорию (x).

Каждый файл имеет три категории пользователей, для которых можно устанавливать различные сочетания прав доступа:

 - **владелец** - набор прав для владельца файла, пользователя, который его создал или сейчас установлен его владельцем;

 - **группа** - любая группа пользователей, существующая в системе и привязанная к файлу;

 - **остальные** - все пользователи, кроме владельца и пользователей, входящих в группу файла.

Информация о правах доступа к файлу представлена в виде **10** символов.
Первый символ определяет тип файла. Если первый символ ```-```, то это обычный файл. Если первый символ d, то это каталог.
Следующие 3 символа показывают разрешения для владельца. Буква означает наличие разрешения, а прочерк — его отсутствие.
Следующие 3 символа показывают разрешения для группы. Порядок записи разрешений всегда такой: чтение, запись, выполнение. 
Последние 3 символа показывают разрешения для всех остальных пользователей[@key-2].

Для того, чтобы позволить обычным пользователям выполнять программы от имени суперпользователя без знания его пароля придуманы SetUID и SetGID биты [@key-3]. 

- **SetUID** - если этот бит установлен, то при выполнении программы, id пользователя, от которого она запущена заменяется на id владельца файла. Фактически, это позволяет обычным пользователям запускать программы от имени суперпользователя;

- **SetGID** - этот флаг работает аналогичным образом, только разница в том, что пользователь считается членом группы, с которой связан файл, а не групп, к которым он действительно принадлежит. Если SGID флаг установлен на каталог, все файлы, созданные в нем, будут связаны с группой каталога, а не пользователя. Такое поведение используется для организации общих папок;

- **Sticky-bit** - этот бит тоже используется для создания общих папок. Если он установлен, то пользователи могут только создавать, читать и выполнять файлы, но не могут удалять файлы, принадлежащие другим пользователям.

Для изменения владельца и группы файла или каталога есть команда chown [@key-4].

Используется следующий шаблон выполнения данной команды chown:

```sudo chown имя_нового_владельца:имя_новой_группы имя_файла_или_директории```

# Выполнение лабораторной работы

## Создание программы

1. Вошла в систему от имени пользователя guest (рис. @fig:001). Убедилась, что в системе установлен компилятор gcc, проверив версию командой ```gcc -v``` (рис. @fig:001). Видим, что он установлен. Отключила систему запретов до очередной перезагрузки командой ```setenforce 0``` (рис. @fig:001). После этого команда ```getenforce``` выводит "Permissive" (рис. @fig:001).

![Подготовка лабораторного стенда](image/1.png){#fig:001 width=70%}

2. Создала программу simpleid.c в текстовом редакторе nano (рис. @fig:002). 

3. Cкомпилировала программу и убедилась, что файл программы создан, командой ```gcc simpleid.c -o simpleid``` (рис. @fig:002). 

4. Выполнила программу simpleid, введя ```./simpleid``` (рис. @fig:002).

5. Выполнила системную программу id (рис. @fig:002). Видим, что выводимая информация о uid и gid идентична, но команда ```id``` также выводит groups=1001(guest).

![Программа simpleid](image/2.png){#fig:002 width=70%}

6. Усложнила программу, добавив вывод действительных идентификаторов (рис. @fig:003). Получившуюся программу назвала simpleid2.c (рис. @fig:003). 

7. Cкомпилировала программу командой ```gcc simpleid2.c -o simpleid2``` (рис. @fig:003). Запустила программу, введя ```./simpleid2``` (рис. @fig:003).

![Программа simpleid2](image/3.png){#fig:003 width=70%}

8. Выполнила команды ```sudo chown root:guest /home/guest/simpleid2``` и ```sudo chmod u+s /home/guest/simpleid2``` (рис. @fig:004).

9. Первая команда меняет у файла владельца и группу. Вторая команда ставит SetUID-бит.

10. Выполнила проверку правильности установки новых атрибутов и смены владельца файла simpleid2 с помощью команды ```ls -l simpleid2``` (рис. @fig:004). Видим, что все установлено верно.

11. Запустила файл simpleid2 командой ```./simpleid2``` (рис. @fig:004). Также выполнила системную команду ```id``` (рис. @fig:004). Видим, что файл выводит информацию не только о реальном идентификаторе, но и эффективных ID - EUID и EGID. Фактические ID пользователя и группы соответствуютт ID пользователя, который вызвал процесс (пользователь guest, группа guest). Эффективный ID пользователя соответствует установленному SetUid биту на исполняемом файле (привелегии суперпользователя). Эффективный ID группы соответствует установленному SetGid биту на исполняемом файле.Команда ```id``` выводит информацию только о реальном идентификаторе.

12. Проделала то же самое относительно SetGID-бита (рис. @fig:004). Видим, что теперь при исполнении файла выводится EUID = 1001, EGID = 0, так как мы установили SetGid бит.

![SetUID- и SetGID-биты](image/4.png){#fig:004 width=70%}

13. Создала программу readfile с помощью тектового редактора nano (рис. @fig:005).

14. Откомпилировала её командой ```gcc readfile.c -o readfile``` (рис. @fig:005).

![Файл readfile.c](image/5.png){#fig:005 width=70%}

15. Сменила владельца у файла readfile.c на root командой ```sudo chown root /home/guest/readfile``` и изменила права так, чтобы только суперпользователь
(в моем случае владелец) мог прочитать его, a guest (член группы) не мог командой ```sudo chmod 733 /home/guest/readfile``` (рис. @fig:006).

16. Проверила, что пользователь guest не может прочитать файл readfile.c командой ```cat readfile.c``` (рис. @fig:006). Видим, что нам действильно отказано в доступе. 

17. Сменила у программы readfile владельца обратно на guest и установила SetUID-бит командами ```sudo chown guest:guest /home/guest/readfile``` и ```sudo chmod u+s /home/guest/readfile``` (рис. @fig:006). 

![Смена владельца файла readfile.c](image/6.png){#fig:006 width=70%}

18. Проверила, может ли программа readfile прочитать файл readfile.c (рис. @fig:007). Видим, что может, так как мы установили SetUID-бит.

![Чтение файла readfile.c](image/7.png){#fig:007 width=70%}

19. Проверилп, может ли программа readfile прочитать файл /etc/shadow (рис. @fig:008). Видим, что может, так как мы установили SetUID-бит.

![Чтение файла /etc/shadow](image/8.png){#fig:008 width=70%}

## Исследование Sticky-бита

1. Выяснила, установлен ли атрибут Sticky на директории /tmp, для чего выполнила команду
```ls -l / | grep tmp``` (рис. @fig:009). Видим, что он установлен (буква t в конце). 

2. От имени пользователя guest создала файл file01.txt в директории /tmp со словом test командой ```echo "test" > /tmp/file01.txt``` (рис. @fig:009). 

3. Просмотрела атрибуты у только что созданного файла (```команда  ls -l /tmp/file01.txt```) и разрешила чтение и запись для категории пользователей «все остальные» командой ```chmod o+rw /tmp/file01.txt``` (рис. @fig:009). Проверила атрибуты (```команда  ls -l /tmp/file01.txt```) (рис. @fig:009).

![Проверка наличия Sticky-бита на директории /tmp](image/9.png){#fig:009 width=70%}

4. От пользователя guest2 (не являющегося владельцем) попробовала прочитать файл /tmp/file01.txt командой ```cat /tmp/file01.txt``` (рис. @fig:010). Прочитать файл удалось. 

5. От пользователя guest2 попробовала дозаписать в файл
/tmp/file01.txt слово test2 командой ```echo "test2" >> /tmp/file01.txt``` (рис. @fig:010). Выполнить данную операцию не удалось.

6. Проверила содержимое файла командой ```cat /tmp/file01.txt``` (рис. @fig:010). Действие по сути бессмысленное, так как файл не менялся. 

7. От пользователя guest2 попробовала записать в файл /tmp/file01.txt
слово test3, стерев при этом всю имеющуюся в файле информацию командой
```echo "test3" > /tmp/file01.txt``` (рис. @fig:010). Выполнить эту операцию не удалось.

8. Проверила содержимое файла командой ```cat /tmp/file01.txt``` (рис. @fig:010). Действие по сути бессмысленное, так как файл не менялся. 

9. От пользователя guest2 попробовала удалить файл /tmp/file01.txt командой
```rm /tmp/fileOl.txt``` (рис. @fig:010). 

![Проверка возможности действий при наличии Sticky-бита](image/10.png){#fig:010 width=70%}

10. Повысила свои права до суперпользователя следующей командой ```su -```
и выполнида после этого команду ```chmod -t /tmp```, снимающую атрибут t (Sticky-бит) с
директории /tmp (рис. @fig:011).

11. Покинула режим суперпользователя командой
```exit``` (рис. @fig:011)

![Снятие Sticky-бита](image/11.png){#fig:011 width=70%}

12. От пользователя guest2 проверила, что атрибута t у директории /tmp нет командой ```ls -l / | grep tmp``` (рис. @fig:012).

13. Повторила предыдущие шаги (рис. @fig:012). Теперь мы смогли удалить файл.

14. Нам удалось удалить файл, когда мы сняли Sticky-бит. 

![Проверка возможности действий при отсутствии Sticky-бита](image/12.png){#fig:012 width=70%}

15. Повысила свои права до суперпользователя и вернула атрибут t на директорию /tmp (рис. @fig:013).

![Установка Sticky-бита](image/13.png){#fig:013 width=70%}

# Выводы

Я изучила механизмы изменения, применения SetUID- и Sticky-битов. Получила практические навыки работы в консоли с дополнительными атрибутами. Рассмотрела работу механизма смены идентификатора процессов пользователей, а также влияние бита Sticky на запись и удаление файлов.

# Список литературы{.unnumbered}

::: {#refs}
:::
